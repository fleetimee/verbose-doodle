# AGENTS.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **Biller Simulator** application built with React 19, TypeScript, and Vite. The application helps teams prototype billing scenarios using configurable JSON data and reusable UI components.

**Package Manager:** This project uses **bun** as the package manager and runtime.

## Development Commands

### Running the Application

- `bun dev` - Start Vite development server with HMR
- `bun preview` - Preview production build locally

### Building

- `bun build` - Type-check with `tsc -b` and build with Vite

### Linting & Formatting

- `bun lint` - Check code with Ultracite (Biome wrapper)
- `bun fix` - Auto-fix linting and formatting issues
- `bunx ultracite fix --unsafe` - Apply unsafe fixes (use with caution)
- `bunx ultracite doctor` - Validate Ultracite/Biome setup

### Package Management

- `bun install` - Install dependencies
- `bun add <package>` - Add a new dependency
- `bun remove <package>` - Remove a dependency

## Architecture

### Routing

The application uses **React Router v7** (from `react-router` package) configured in `src/main.tsx`:

- Routes are defined at the root level using `<BrowserRouter>`, `<Routes>`, and `<Route>` components
- Current routes: `/` (main app) and `/about` (about page)
- To add new routes, define them in `src/main.tsx` and create corresponding page components in `src/pages/`

### Component Structure

- **UI Components**: Located in `src/components/ui/`, these are reusable components built with Radix UI primitives (shadcn/ui)
- **Pages**: Located in `src/pages/`, these are route-level components
- **Utilities**: `src/lib/utils.ts` contains the `cn()` helper for merging Tailwind classes with `clsx` and `tailwind-merge`

**Important Note on shadcn/ui Components:**

- The `src/components/ui/` directory contains shadcn/ui components which have relaxed linting rules
- These components may be regenerated by the shadcn CLI, so they maintain their own code style
- Biome linting/formatting is disabled or relaxed for these files via `biome.json` overrides
- DO NOT manually apply strict linting rules to these components
- The same applies to `src/hooks/` which contains utility hooks from shadcn

### Recommended Folder Structure (Feature-Based)

For scalability, organize code by feature rather than by type. Here's the recommended structure:

```
src/
├── components/
│   └── ui/              # Shared UI primitives (Button, Input, etc.)
├── features/            # Feature-based organization
│   ├── billing/
│   │   ├── components/  # Billing-specific components
│   │   ├── hooks/       # Billing-specific hooks
│   │   ├── types.ts     # Billing-specific types
│   │   └── utils.ts     # Billing-specific utilities
│   ├── scenarios/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── types.ts
│   │   └── utils.ts
│   └── customers/
│       ├── components/
│       ├── hooks/
│       ├── types.ts
│       └── utils.ts
├── lib/                 # Shared utilities
├── pages/               # Route-level components (thin, compose features)
├── types/               # Global type definitions
└── main.tsx             # Application entry point
```

**Feature Organization Principles:**

- Each feature folder contains all related components, hooks, types, and utilities
- Page components should be thin wrappers that compose feature components
- Shared/generic components stay in `components/ui/`
- Move code to `features/` when it's specific to a domain concept (e.g., billing, invoices, payment methods)
- Co-locate tests next to the code they test (e.g., `billing/components/InvoiceCard.test.tsx`)

**Example Feature Structure for Billing Scenarios:**

```
src/features/billing-scenarios/
├── components/
│   ├── ScenarioCard.tsx
│   ├── ScenarioEditor.tsx
│   └── ScenarioPreview.tsx
├── hooks/
│   ├── useScenario.ts
│   └── useScenarioValidation.ts
├── types.ts              # BillingScenario, ScenarioConfig, etc.
└── utils.ts              # calculateTotal, formatCurrency, etc.
```

### Styling

- **Tailwind CSS v4** configured via `@tailwindcss/vite` plugin in `vite.config.ts`
- Uses `class-variance-authority` for variant-based component styling (see `button.tsx`)
- `tw-animate-css` package available for animations

### React Compiler

The React 19 Compiler is enabled via `babel-plugin-react-compiler`. This provides automatic memoization but may impact dev/build performance.

### Data Fetching & State Management

- **TanStack React Query v5** for server state management
  - Configured in `src/lib/query-client.ts` with default staleTime (5min) and gcTime (10min)
  - Query/Mutation factory functions in `src/lib/query-hooks.ts` for type-safe hooks
  - Generic API wrapper in `src/lib/api.ts` with timeout and error handling
  - Example implementations in `src/lib/query-example.ts` (reference only)
- **React Hook Form v7** with Zod schema validation for form handling
- **next-themes** for theme management (light/dark/system modes)

### Path Aliases

- `@/*` maps to `./src/*` (configured in both `tsconfig.json` and `vite.config.ts`)
- Example: `import { Button } from "@/components/ui/button"`

**IMPORTANT: Always use the `@/` path alias for all imports:**

- Use `@/` for all imports within the `src/` directory
- NEVER use relative paths like `./` or `../` for imports
- This ensures consistency, improves code maintainability, and makes refactoring easier

Examples:

```typescript
// ✅ GOOD - Use @/ alias
import { Button } from "@/components/ui/button";
import { LoginForm } from "@/features/login/components/login-form";
import { apiGet } from "@/lib/api";
import { Home } from "@/pages/home";

// ❌ BAD - Don't use relative paths
import { Button } from "../../components/ui/button";
import { LoginForm } from "../components/login-form";
import { apiGet } from "./api";
import HomePage from "./pages/home";
```

### Exports

**IMPORTANT: Always use named exports, never default exports:**

- Use `export function ComponentName()` or `export const ComponentName =`
- NEVER use `export default`
- This provides better IDE support, refactoring capabilities, and consistency

Examples:

```typescript
// ✅ GOOD - Named exports
export function Home() {
  return <div>Home Page</div>;
}

export const Login = () => {
  return <div>Login Page</div>;
};

// ❌ BAD - Default exports
function Home() {
  return <div>Home Page</div>;
}
export default Home;

export default function Login() {
  return <div>Login Page</div>;
}
```

## Code Quality Standards

This project enforces strict code quality rules via **Ultracite** (wrapping Biome).

**Configuration Notes:**

- Strict rules apply to all application code (`src/features/`, `src/pages/`, `src/lib/`, etc.)
- Relaxed rules for `src/components/ui/**` and `src/hooks/**` (shadcn/ui components)
- See `biome.json` for the complete configuration including overrides
- The overrides disable formatting, sorting, accessibility checks, and certain style rules for shadcn components

Key standards include:

### Accessibility

- All interactive elements must be keyboard accessible
- Provide meaningful alt text and ARIA labels
- No `aria-hidden` on focusable elements
- Pair mouse events with keyboard equivalents

### TypeScript

- No `any` type (use proper types or `unknown`)
- No `enum` (use const objects or unions instead)
- No namespaces
- Use `export type` and `import type` for types
- Mark readonly properties that don't change

### React Best Practices

- Hooks must be called from top level of components
- Specify all dependencies in hook arrays
- No `dangerouslySetInnerHTML` with children
- Use `type` attribute on buttons

### Modern JavaScript

- Use arrow functions over function expressions
- Use `for...of` instead of `Array.forEach`
- Use template literals instead of string concatenation
- Use `const` for values only assigned once
- No `console`, `debugger`, `alert`, `confirm`, or `prompt`

### File Naming

- Use kebab-case for filenames
- Keep filenames ASCII-compatible

## IDE Integration

Configure your editor with the **Ultracite (Biome) extension** for automatic formatting and linting on save. Ultracite provides instant feedback and the same configuration powers both IDE and CLI checks via `biome.json`.
